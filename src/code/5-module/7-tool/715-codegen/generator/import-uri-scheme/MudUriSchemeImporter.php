<?php declare( strict_types = 1 );

// 2021-03-22 jj5 - SEE: Uniform Resource Identifier (URI) Schemes:
// https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml

// 2021-03-22 jj5 - we pinch our list of URI Schemes from the list maintained here:
//
define( 'MUD_CODEGEN_URI_SCHEME_CSV_URL', 'https://www.iana.org/assignments/uri-schemes/uri-schemes-1.csv' );

define( 'MUD_CODEGEN_URI_SCHEME_DATA_DIR', realpath( __DIR__ . '/dat' ) );

// 2021-03-22 jj5 - the CSV file is just a cache of the data from the URL which we download...
//
define( 'MUD_CODEGEN_URI_SCHEME_CSV_FILE', MUD_CODEGEN_URI_SCHEME_DATA_DIR . '/uri-schemes.csv' );

// 2021-03-21 jj5 - the JSON file records which URI schemes have been allocated which ID values.
// It's important that we remember forever which ID was allocated for each scheme and that we can
// detect when new schemes require new ID values... so this file is very important and deleting
// it would quite possibly create problems.
//
define( 'MUD_CODEGEN_URI_SCHEME_JSON_FILE', MUD_CODEGEN_URI_SCHEME_DATA_DIR . '/uri-schemes.json' );

// 2021-03-21 jj5 - these are the output PHP files generated by this script...
//
define( 'MUD_CODEGEN_URI_SCHEME_CONSTS_FILE',  'uri-scheme-consts.php' );
define( 'MUD_CODEGEN_URI_SCHEME_ENUM_FILE',    'uri-scheme-enum.php' );
define( 'MUD_CODEGEN_URI_SCHEME_SCHEMA_FILE',  'uri-scheme-schema.php' );


class MudUriSchemeImporter extends MudGenerator {

  protected $verbose = true, $debug = false, $script_path = null, $target = null, $test = null;

  function run( $argv ) {


    //
    // 2021-03-22 jj5 - set up and check our environemnt...
    //

    if ( $argv === null ) {

      die( 'This is a command-line app, not a web app.' );

    }


    //
    // 2021-03-22 jj5 - declare our supported tests...
    //

    $tests = [
      'invalid-char-1'  => $this->test( 'this|is|an|invalid|scheme', 1337  ),
      'invalid-char-2'  => $this->test( "this\nis\ninvalid\ntoo",    1337  ),
      'invalid-char-3'  => $this->test( '1337-is-invalid-start',     1337  ),
      'invalid-quote-1' => $this->test( "hack'; drop table users;",  1337  ),
      'invalid-quote-2' => $this->test( 'hack"; drop table staff;',  1337  ),
      'bad-sequence'    => $this->test( "this-is-an-invalid-id",     1337  ),
      'non-int-id-1'    => $this->test( 'this-is-an-invalid-id',     null  ),
      'non-int-id-2'    => $this->test( 'this-is-an-invalid-id',     '37'  ),
      'non-int-id-3'    => $this->test( 'this-is-an-invalid-id',     13.7  ),
      'non-int-id-4'    => $this->test( 'this-is-an-invalid-id',     "'4'" ),
      'negative-id'     => $this->test( 'this-is-an-invalid-id',     -123  ),
    ];


    //
    // 2021-03-22 jj5 - parse our command-line...
    //

    if ( ! file_exists( basename( $this->script_path = array_shift( $argv ) ) ) ) {

      $this->error( 'not in script directory.', MUD_TOOL_EXIT_WRONG_DIR );

    }

    $this->target = array_shift( $argv );

    if ( ! is_dir( $this->target ) ) {

      $this->error( 'invalid target.', MUD_TOOL_EXIT_INVALID_TARGET );

    }

    $this->script_path = realpath( $this->script_path );

    while ( $arg = array_shift( $argv ) ) {

      switch ( $arg ) {

        case '--debug'    : $this->debug    = true;   break;
        case '--verbose'  : $this->verbose  = true;   break;
        case '--quiet'    : $this->verbose  = false;  break;

        case '--test'     :

          $test = array_shift( $argv );

          if ( ! array_key_exists( $test, $tests ) ) {

            $this->value_error( 'unsupported test', $test, MUD_TOOL_EXIT_UNKNOWN_TEST );

          }

          $this->test = $tests[ $test ];

          break;

        default :

          $this->value_error( 'unsupported argument', $arg, MUD_TOOL_EXIT_UNKNOWN_ARG );

      }
    }


    //
    // 2021-03-22 jj5 - set up our file system...
    //

    if ( ! is_dir( MUD_CODEGEN_URI_SCHEME_DATA_DIR ) ) {

      mkdir( MUD_CODEGEN_URI_SCHEME_DATA_DIR );

    }


    //
    // 2021-03-22 jj5 - get our existing data or declare initial data...
    //

    if ( file_exists( MUD_CODEGEN_URI_SCHEME_JSON_FILE ) ) {

      $this->report( 'loading existing JSON from ' . MUD_CODEGEN_URI_SCHEME_JSON_FILE );

      $schemes = json_decode( file_get_contents( MUD_CODEGEN_URI_SCHEME_JSON_FILE ), $assoc = true );

    }
    else {

      $this->report( 'using default data' );

      // 2021-03-21 jj5 - here we start things off using some of our preferred URI schemes first.
      // Other URI schemes will be loaded and allocated an ID.
      //
      $schemes = [ 'https' => 1, 'http' => 2, 'file' => 3 ];

    }

    $max_id = 0;

    foreach ( $schemes as $scheme => $id ) {

      $max_id = max( $id, $max_id );

    }

    $this->report( 'max ID is ' . $max_id );

    $next_id = $max_id + 1;


    //
    // 2021-03-22 jj5 - get our CSV file, either we already have one we can use or we download...
    //

    if ( $this->debug && file_exists( MUD_CODEGEN_URI_SCHEME_CSV_FILE ) ) {

      // 2021-03-21 jj5 - if we're debugging and the file exists don't download a new file...

      $this->report( 'loading data from ' . MUD_CODEGEN_URI_SCHEME_CSV_FILE );

    }
    else {

      // 2021-03-21 jj5 - we're not debugging or the CSV file is missing so get the latest data
      // from the web...

      $this->report( 'downloading data from ' . MUD_CODEGEN_URI_SCHEME_CSV_URL );

      $user_agent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:86.0) Gecko/20100101 Firefox/86.0';

      $options = [
        'http' => [
          'method' => 'GET',
          'header' =>
            //"Accept-language: en\r\n" .
            //"Cookie: foo=bar\r\n" .
            "User-Agent: $user_agent\r\n"
        ]
      ];

      $context = stream_context_create( $options );

      $csv = file_get_contents( MUD_CODEGEN_URI_SCHEME_CSV_URL, false, $context );

      file_put_contents( MUD_CODEGEN_URI_SCHEME_CSV_FILE, $csv );

    }


    //
    // 2021-03-22 jj5 - parse our CSV file...
    //

    if ( ( $handle = fopen( MUD_CODEGEN_URI_SCHEME_CSV_FILE, 'r' ) ) === false ) {

      $this->value_error( 'cannot read file', MUD_CODEGEN_URI_SCHEME_CSV_FILE, MUD_TOOL_EXIT_CANT_READ );

    }

    $index = 0;

    while ( ( $record = fgetcsv( $handle ) ) !== false ) {

      // 2021-03-22 jj5 - skip the first line as it only contains headings...
      //
      if ( $index++ === 0 ) {

        assert( $record[ 0 ] === 'URI Scheme' );

        continue;

      }

      $scheme = $record[ 0 ];

      if ( ! array_key_exists( $scheme, $schemes ) ) {

        $schemes[ $scheme ] = $next_id++;

      }
    }

    if ( fclose( $handle ) === false ) {

      $this->value_error( 'cannot close file', MUD_CODEGEN_URI_SCHEME_CSV_FILE, MUD_TOOL_EXIT_CANT_CLOSE );

    }


    //
    // 2021-03-22 jj5 - if we're running a test do the set up for that...
    //

    if ( $this->test ) { $schemes[ $this->test[ 'scheme' ] ] = $this->test[ 'id' ]; }


    //
    // 2021-03-22 jj5 - do our data validation...
    //

    // 2021-03-22 jj5 - we validate the schemes before we do code generation with them, because
    // we don't want any funny business with code injection... doing validation at this point in
    // the code means we cover schemes loaded from JSON and also from CSV.
    //
    $this->validate_schemes( $schemes );


    //
    // 2021-03-22 jj5 - save our scheme data to JSON for posterity...
    //

    $count = count( $schemes );

    $this->report( "writing $count URI schemes to " . MUD_CODEGEN_URI_SCHEME_JSON_FILE );

    file_put_contents( MUD_CODEGEN_URI_SCHEME_JSON_FILE, json_encode( $schemes, JSON_PRETTY_PRINT ) );


    //
    // 2021-03-22 jj5 - calculate max scheme length, used for padding...
    //

    $max_len = 0;

    foreach ( $schemes as $scheme => $id ) {

      $max_len = max( $max_len, strlen( $scheme ) );

    }

    $this->report( "scheme max length is $max_len characters" );


    //
    // 2021-03-22 jj5 - do our code generation...
    //

    $this->gen_consts( $schemes, $max_len );
    $this->gen_enum( $schemes, $max_len );
    $this->gen_schema( $schemes, $max_len );


    //
    // 2021-03-22 jj5 - we're done, warn user if there are changes...
    //

    if ( $count === $max_id ) { return; }

    // 2021-03-21 jj5 - THINK: there is probably a better way to send this alert... maybe we
    // should email someone..? In theory this script gets run manually so there should be an
    // operator reading this output...
    //
    mud_stderr( "**********************************************************************" );
    mud_stderr( "*** NEW ITEMS DETECTED, YOU MUST UPDATE THE SCHEMA REVISION NUMBER ***" );
    mud_stderr( "**********************************************************************" );

  }

  protected function test( $scheme, $id ) {

    return [ 'scheme' => $scheme, 'id' => $id ];

  }

  protected function validate_schemes( $schemes ) {

    $counter = 1;

    foreach ( $schemes as $scheme => $id ) {

      // 2021-03-22 jj5 - this regex isn't designed to be perfect, just to be safe and to pass on
      // valid input...
      //
      if ( $scheme === 'shttp (OBSOLETE)' ) {

        // 2022-02-20 jj5 - ignore this...

      }
      else if ( ! preg_match( '/^[a-z][a-z0-9\.\-\+]+$/', $scheme ) ) {

        $this->invalid_value( 'scheme is in an invalid format', $scheme );

      }

      if ( ! is_int( $id ) ) {

        $this->invalid_value( 'scheme ID is not an integer', $id );

      }

      if ( $id <= 0 ) {

        $this->invalid_value( 'scheme ID is not positive', $id );

      }

      if ( $id !== $counter++ ) {

        $this->invalid_value( 'scheme ID is out of sequence', $id );

      }
    }
  }

  protected function invalid_value( $problem, $value ) {

    $this->fail( "$problem: " . json_encode( $value, JSON_UNESCAPED_SLASHES ) );

  }

  protected function gen_consts( $schemes, $max_len ) {

    $file = $this->target . '/' . MUD_CODEGEN_URI_SCHEME_CONSTS_FILE;

    $this->report( "generating $file" );

    ob_start();

    $this->print_consts( $schemes, $max_len );

    $code = ob_get_clean();

    file_put_contents( $file, $code );

  }

  protected function gen_enum( $schemes, $max_len ) {

    $file = $this->target . '/' . MUD_CODEGEN_URI_SCHEME_ENUM_FILE;

    $this->report( "generating $file" );

    ob_start();

    $this->print_enum( $schemes, $max_len );

    $code = ob_get_clean();

    file_put_contents( $file, $code );

  }

  protected function gen_schema( $schemes, $max_len ) {

    $file = $this->target . '/' . MUD_CODEGEN_URI_SCHEME_SCHEMA_FILE;

    $this->report( "generating $file" );

    ob_start();

    $this->print_schema( $schemes, $max_len );

    $code = ob_get_clean();

    file_put_contents( $file, $code );

  }

  function print_consts( $schemes, $max_len ) {

    $this->print_header();

    foreach ( $schemes as $scheme => $id ) :

      if ( $this->is_obsolete( $scheme ) ) { continue; }

      $name = str_pad( "'MUD_URI_SCHEME_" . $this->get_const( $scheme ). "',", $max_len + 18 );
      $string = str_pad( "'$scheme'", $max_len + 2 );

  ?>
  define( <?= $name ?> <?= $string ?> );
<?php

    endforeach;

  }

  protected function print_enum( $schemes, $max_len ) {

    $this->print_header();

  ?>
  abstract class MudUriScheme extends MudEnum {

    use MudEnumTraits;

<?php

    foreach ( $schemes as $scheme => $id ) :

      if ( $this->is_obsolete( $scheme ) ) { continue; }

      $name = str_pad( $this->get_const( $scheme ), $max_len );
      $id = str_pad( "$id", 3, ' ', STR_PAD_LEFT );

  ?>
    const <?= $name ?> = <?= $id ?>; // '<?= $scheme ?>'
<?php

    endforeach;

  ?>

    static $map = [
<?php

    foreach ( $schemes as $scheme => $id ) :

      if ( $this->is_obsolete( $scheme ) ) { continue; }

      $const = $this->get_const( $scheme );
      $name = str_pad( $const, $max_len );

  ?>
      MUD_URI_SCHEME_<?= $name ?> => self::<?= $const ?>,
<?php

    endforeach;

  ?>
    ];

  }
<?php

  }

  protected function print_schema( $schemes, $max_len ) {

    static $ports = [ 'https' => 443, 'http' => 80 ];

    $this->print_header();

  ?>

      def_dat( 't_lookup_std_uri_scheme',
        [
          'a_std_uri_scheme_enum' => null,
          'a_std_uri_scheme_code' => null,
          'a_std_uri_scheme_standard_port' => 0,
        ], [
        [ 0, '', 0 ],
<?php

    foreach ( $schemes as $scheme => $id ) :

      if ( $this->is_obsolete( $scheme ) ) { continue; }

      $name = str_pad( $this->get_const( $scheme ). ',', $max_len + 1 );
      $port = str_pad( strval( $ports[ $scheme ] ?? 0 ), 5 );

  ?>
        [ MudUriScheme::<?= $name ?> MUD_URI_SCHEME_<?= $name ?> <?= $port ?> ], // '<?= $scheme ?>'
<?php

    endforeach;

  ?>
      ]);

<?php

  }

  protected function print_header() {

    static $path = null;

    if ( $path === null ) {

      $path = preg_replace( '|.*/bin/|', 'bin/', $this->script_path );

    }

    echo "<?php\n";

  ?>

  //
  // this file generated by <?= "$path\n" ?>
  //

<?php

  }

  protected function is_obsolete( $scheme ) {

    if ( strpos( $scheme, '(OBSOLETE)' ) ) {

      return true;

    }

    return false;

  }

  protected function get_const( $scheme ) {

    $parts = explode( ' ', $scheme );

    $scheme = $parts[ 0 ];

    return preg_replace( '/\.|\-|\+/', '_', strtoupper( $scheme ) );

  }
}
