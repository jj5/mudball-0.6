<?php


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 2024-02-08 jj5 - class definition...
//

// 2024-02-09 jj5 - NOTE: this is the base class for all module classes in the system. A module is a bunch of code --
// comprising interfaces, traits, classes, functions, and so on -- that is designed to be used together to provide a
// specific set of functionality. Modules are the primary way that code is organised in the mudball system. Modules are
// defined by this library to and can be further specialized and used in an application.

// 2024-02-09 jj5 - NOTE: each module will define its own set of unit tests.

// 2024-02-09 jj5 - NOTE: modules in the system have a three digit code and a name. The three digit code is used to
// indicate the dependency order of the modules. In theory no module should depend on a module with a higher code. When
// modules are tightly coupled (that is they depend on each other) they will share a module code. For example the
// 115-{error,exit} modules are tightly coupled and share the module code 115.

// 2024-02-09 jj5 - NOTE: a module will typically define a module class extending MudModule and provide access to an
// instance of that class via a service locator function. Typically the module will also define a number of functions which
// defer their implementation to an instance of the module class via its service locator. See mud_module.php in this module
// for an example of how to define a module class (MudModuleStandard) and its service locator function (mud_module_standard).

// 2024-02-09 jj5 - NOTE: as can be seen from the inheritance hierarchy a module class defines a type of service.

abstract class MudModule extends MudService {


  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // 2024-02-08 jj5 - private static fields...
  //

  private static array $module_map = [];


  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // 2024-02-08 jj5 - constructor...
  //

  public function __construct( MudModule|null $previous ) {

    parent::__construct( $previous );

    $class = get_class( $this );

    self::$module_map[ $class ] = $this;

  }


  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // 2024-02-08 jj5 - protected methods...
  //

  // 2024-02-09 jj5 - NOTE: modules can define constants indirectly (that is by not calling the define() function directly)
  // in which case the IDE will not be able to confirm the existence of the constant. This function can be used to save the
  // constants defined by a module into a generated file which will help the IDE to confirm the existence of the constants.

  protected function save_constant_map( array $spec, Closure|null $skip = null ) {

    $self = get_class( $this );

    $path = __DIR__ . "/../../../../gen/constant/$self.php";

    $map = [];

    if ( file_exists( $path ) ) {

      $lines = file( $path );

      for ( $i = 0; $i < count( $lines ); $i++ ) {

        $line = trim( $lines[ $i ] );

        if ( ! preg_match( "/define\( '([^']*)'/", $line, $matches ) ) { continue; }

        $name = $matches[ 1 ];

        $map[ $name ] = $line;

      }
    }

    foreach ( $spec as $code => $item ) {

      $name = $item[ 'name' ];

      if ( is_callable( $skip ) && $skip( $name ) ) { continue; }

      $line = "define( '$name', $code );";

      $map[ $name ] = $line;

    }

    $result = [
      '<?php',
      '// 2024-02-09 jj5 - this code is generated by ' . get_class( $this ),
      ...array_values( $map ),
      '',
    ];

    file_put_contents( $path, implode( "\n", $result ) );

  }
}
